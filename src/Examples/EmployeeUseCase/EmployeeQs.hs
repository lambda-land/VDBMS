-- | vqs for employee database.
module Examples.EmployeeUseCase.EmployeeQs where

import Prelude hiding (Ordering(..))

import qualified VDBMS.QueryLang.RelAlg.Variational.Algebra as A
-- import qualified VDBMS.QueryLang.RelAlg.Variational.Condition as C
import qualified VDBMS.Features.FeatureExpr.FeatureExpr as F
import VDBMS.VDB.Name
import VDBMS.Variational.Opt 
import Database.HDBC
import VDBMS.DBMS.Value.Value
import Examples.EmployeeUseCase.EmployeeSchema

-- import Database.HDBC 
-- import Data.Time.LocalTime
import Data.Time.Calendar

-- keep in mind that the employee use demos deploying
-- every single version for the client of spl. so qs
-- must be st the software generated by spl is actually
-- using it. i.e. qs aren't being run in the test, instead
-- they're running in deployment step. or better yet 
-- you can imagine that different divisions of the company
-- are using different versions of it. so qs demo situations
-- that the user/software has some information need that 
-- needs to get data from different versions. keep in mind
-- that the user/software can definitely specify the version
-- they're requiring at the end, which just requires applying
-- configuration to the final result of a vq or getting the
-- plain q of a vq and then running it on the appropriate 
-- variant. 

newtype QueryT = QueryT String
  deriving (Show, Eq)

-- | attaches the feature expression true to an attribute. 
trueAtt :: Attribute -> Opt Attribute
trueAtt a = (F.Lit True, a)

vq0, vq1, vq2, vq3 :: A.Algebra

-- \pi_name empacct
vq0 = A.Proj [trueAtt nameAtt]
           (A.TRef empacct)

-- \pi_{name^v3, empno^v4} empacct
vq1 = A.Proj [(empv3, nameAtt), (empv4, empno)]
           (A.TRef empacct)

-- \pi_name empv3<empacct, empacct \bowtie empbio>
vq2 = A.Proj [trueAtt nameAtt] $
      A.AChc empv3 (A.TRef empacct) $
                  A.SetOp A.Prod (A.TRef empacct) (A.TRef empbio)

-- \pi_title (\sigma_{v3<salary > 5000, salary > 10000>} job)
vq3 = A.Proj [trueAtt title] $
           A.Sel (A.CChc empv3 empCond' empCond'') $
               A.TRef job

-- 
-- first set of quesries:
-- taken from the prima paper, adjusted to the employee database. 
-- e.g. instead of year 2003, we have year 1991, etc. 
-- can be used for comparison in terms of expressiveness and brevity.
-- 

-- intent: return the salary value of the emp 10004
--         on the year 1991. 
-- query: 
-- prj_salary 
--    (sel_(empNo=10004, 1991-01-01<hiredate<1992-01-01)
--            prj_(empno, hiredate, salary) 
--                empacct join_(title=title) job)
-- note:
-- the year 1991 is included in variants v3, v4, and v5. we only
-- write the query for these variants for a fair comparison against
-- prima.
-- classification: 3-0-2-1
empVQ1 :: A.Algebra
empVQ1 = A.Proj [trueAtt salary] $
  A.Sel (A.And empCond
             yearCond)
  (A.Proj [trueAtt empno, trueAtt hiredate, trueAtt salary] $ 
    A.Sel (A.Comp EQ (A.Attr title) (A.Attr title)) $ A.SetOp A.Prod (A.TRef empacct) (A.TRef job))

empVQ1T :: QueryT
empVQ1T = QueryT $ 
  "SELECT salary" ++
  "FROM (SELECT empno, hiredate, salary" ++
        "FROM empacct INNER JOIN job)" ++
  "WHERE empNo = 10004 AND 1991-01-01 < hiredate AND hiredate < 1992-01-01"

-- | the year 1991 condition
yearCond :: A.Condition
yearCond = A.And (A.Comp GT (A.Val $ SqlLocalDate $ ModifiedJulianDay 19910101) (A.Attr hiredate))
                 (A.Comp LT (A.Attr hiredate) (A.Val $ SqlLocalDate $ ModifiedJulianDay 19920101))

-- | employee id = 10004 condition
empCond :: A.Condition
empCond = A.Comp EQ (A.Attr empno) (A.Val $ SqlInteger 10004)

empCond' :: A.Condition
empCond' = A.Comp EQ (A.Attr salary) (A.Val $ SqlInteger 50000)

empCond'' :: A.Condition
empCond'' = A.Comp EQ (A.Attr salary) (A.Val $ SqlInteger 10000)


-- more optimized based on relational alg opt rules. prj and sel place
-- have been exchanged. check translations of them to see if they return
-- the same query.
-- classification: 3-0-2-1
empVQ1' :: A.Algebra
empVQ1' = A.Proj [trueAtt salary] $
  A.Proj [trueAtt empno, trueAtt hiredate, trueAtt salary] $ 
    A.Sel (A.And empCond
               yearCond) $
    A.Sel (A.Comp EQ (A.Attr title) (A.Attr title)) $ A.SetOp A.Prod (A.TRef empacct) (A.TRef job)    

-- more optimized based on sel_c sel_c' == sel_{c and c'}
-- classification: 3-0-2-1
empVQ1'' :: A.Algebra
empVQ1'' = A.Proj [trueAtt salary] $
  A.Proj [trueAtt empno, trueAtt hiredate, trueAtt salary] $ 
    A.Sel (empCond
         `A.And` yearCond
         `A.And` (A.Comp EQ (A.Attr title) (A.Attr title))) $ A.SetOp A.Prod (A.TRef empacct) (A.TRef job)    

-- the naive query of empVQ1:
--            v3 or v4 <prj_salary (sel_(empNo=10004, 1991-01-01<hiredate<1992-01-01)
--                                       prj_(empno, hiredate, salary) 
--                                            empacct join_(title=title) job),
--                      prj_salary (sel_(empNo=10004, 1991-01-01<hiredate<1992-01-01) job)>
-- classification: 3-1-2-1
empVQ1naive :: A.Algebra
empVQ1naive = A.AChc (F.Or empv3 empv4)
        (A.Proj [trueAtt salary] $
              A.Sel (A.And empCond
                         yearCond) $
                  A.Proj [trueAtt empno, trueAtt hiredate, trueAtt salary] $ 
                       A.Sel (A.Comp EQ (A.Attr title) (A.Attr title)) $ A.SetOp A.Prod (A.TRef empacct) (A.TRef job))
        (A.Proj [trueAtt salary] $
              A.Sel (A.And empCond
                         yearCond)
                  (A.TRef job))

-- intent: return the managers (of department d001) on
--         the year 1991.
-- query:
-- prj_managerno (sel_(1991-01-01<hiredate<1992-01-01 and deptno = d001)
--                 empacct join_(managerno=empno) dept)
-- note:
-- the naive and manually optimized queries are basically the same.
-- classification: 3-0-2-1
empVQ2 :: A.Algebra
empVQ2 = A.Proj [trueAtt managerno] $
  A.Sel ((A.Comp EQ (A.Attr deptno) (A.Val $ SqlInt32 001))
       `A.And` yearCond
       `A.And` (A.Comp EQ (A.Attr empno) (A.Attr managerno))) $
      A.SetOp A.Prod (A.TRef empacct) (A.TRef dept)

empVQ2T :: QueryT
empVQ2T = QueryT $
  "SELECT managerno" ++
  "FROM empacct INNER JOIN dept ON managerno = empNo" ++
  "WHERE deptno = 001 AND 1991-01-01 < hiredate AND hiredate < 1992-01-01"

-- classification: 5-3-2-1
empVQ2naive :: A.Algebra
empVQ2naive = A.AChc empv3 empVQ2 (A.AChc empv4 empVQ2 $ A.AChc empv5 empVQ2 A.Empty)

-- intent: find all managers that the employee 1004 worked with,
--         on the year 1991. 
-- query:
-- prj_managerno (dept join_(deptno=deptno)
--                prj_deptno (sel_(empNo=10004, 1991-01-01<hiredate<1992-01-01) empacct))
-- note:
-- the naive and manually optimized queries are basically the same.
-- classification: 3-0-2-1
empVQ3 :: A.Algebra
empVQ3 = A.Proj [trueAtt managerno] $
  A.Sel (A.Comp EQ (A.Attr deptno) (A.Attr deptno)) $
      A.SetOp A.Prod (A.TRef dept) $
                 A.Proj [trueAtt deptno] $
                      A.Sel ((A.Comp EQ (A.Attr deptno) (A.Val $ SqlInt32 001))
                          `A.And` yearCond) $
                          A.TRef empacct

empVQ3T :: QueryT
empVQ3T = QueryT $
  "SELECT managerno" ++
  "FROM dept as t0, " ++
                  "(SELECT deptno" ++
                  " FROM empacct" ++
                  " WHERE deptno = 001 AND 1991-01-01 < hiredate AND hiredate < 1992-01-01) as t1" ++
  "WHERE t0.deptno = t1.deptno"

-- ASK Eric: should I consider the first two variants? I think I should! YES!
-- classification: 5-3-2-1
empVQ3naive :: A.Algebra
empVQ3naive = A.AChc empv3 empVQ3 (A.AChc empv4 empVQ3 $ A.AChc empv5 empVQ3 A.Empty)

-- intent: find all salary values of managers in all history,
--         during the period of manager appointment. (the periods
--         of salary and manager appointment need to overlap).
--         answer using data valid on the year 1991.
-- query:
-- prj_salary (((sel_(1991-01-01<hiredate<1992-01-01) empacct)
--              join_(managerno = empno) dept) join_(title = title) job)
-- note: 
-- check to see if the join only occurs for valid variants!!
-- i.e. ... join dept is only valid for v3, v4, and v5. 
-- and ... join job is not valid for v5.
-- classification: 3-0-3-2
empVQ4 :: A.Algebra
empVQ4 = A.Proj [trueAtt salary] $
  (A.Sel (A.Comp EQ (A.Attr title) (A.Attr title))
       (A.SetOp A.Prod (A.Sel (A.Comp EQ (A.Attr managerno) (A.Attr empno))
                        (A.SetOp A.Prod (A.Sel yearCond
                                         (A.TRef empacct))
                                    (A.TRef dept)))
                   (A.TRef job)))

-- classification: 5-3-3-2
empVQ4naive :: A.Algebra
empVQ4naive = A.AChc (F.Or empv3 empv4)
  empVQ4
  (A.AChc empv5 
        (A.Proj [trueAtt salary] $
              A.Sel (A.Comp EQ (A.Attr managerno) (A.Attr empno)) $
                  A.SetOp A.Prod (A.Sel yearCond (A.TRef empacct)) (A.TRef dept))
        A.Empty)

-- intent: find the historical managers of department where the
--         employee 10004 worked, in all history. (the period 
--         of their appointments don't need to overlap.)
--         answer using data valid on the year 1991.
-- query:
-- prj_managerno
--     sel_(1991-01-01<hiredate<1992-01-01)
--         ((sel_(empno == 10004) empacct) join_(deptno = deptno) dept)
-- classification: 3-0-2-1
empVQ5 :: A.Algebra
empVQ5 = A.Proj [trueAtt managerno] $
  A.Sel (A.And yearCond 
             (A.Comp EQ (A.Attr deptno) (A.Attr deptno))) $
      A.SetOp A.Prod (A.Sel empCond (A.TRef empacct))
                 (A.TRef dept)

-- a less efficient vq in terms of relational algebra and sql.
-- since we're joining first and then applying the selection of
-- the particular employee. i.e.:
-- query:
-- prj_managerno
--     sel_(1991-01-01<hiredate<1992-01-01 and empno == 10004)
--         (empacct join_(deptno = deptno) dept)
-- classification: 3-0-2-1
empVQ5' :: A.Algebra
empVQ5' = A.Proj [trueAtt managerno] $
  A.Sel (A.And yearCond $
       A.And empCond 
             (A.Comp EQ (A.Attr deptno) (A.Attr deptno))) $
      A.SetOp A.Prod (A.TRef empacct)
                 (A.TRef dept)

-- classification: 5-3-2-1
empVQ5naive :: A.Algebra
empVQ5naive = A.AChc empv3 empVQ5 $ A.AChc empv4 empVQ5 $ A.AChc empv5 empVQ5 A.Empty

-- classification: 5-1-2-1
empVQ5naive' :: A.Algebra
empVQ5naive' = A.AChc (F.disjFexp [empv3, empv4, empv5]) empVQ5 A.Empty

-- intent: find all salary values of managers in all history.
--         (the periods of salary and manager appointment 
--         don't need to overlap.) 
--         answer using data valid on the year 1991.
-- query:
-- classification:
-- note: there's no way to get the period of manager appointment.
empVQ6 :: A.Algebra
empVQ6 = empVQ4

-- intent: for all managers that the employee 10004 worked with,
--         find all the departments that the manager managed.
--         (temporal join followed by non-temporal join)
--         (10004's and the manager's affiliation with a single 
--         department should overlap, but the manager's manager
--         position periods do not need to overlap, naturally.)
--         answer using data valid on the year 1991.
-- query:
-- prj_deptname
--     empvq3 join_(managerno = managerno) dept
-- classification: 3-0-2-2
empVQ7 :: A.Algebra
empVQ7 = A.Proj [trueAtt deptname] $
  A.Sel (A.Comp EQ (A.Attr managerno) (A.Attr managerno)) $
      A.SetOp A.Prod empVQ3 (A.TRef dept)

-- just wondering about!!
empVQ7naiveHelper :: A.Algebra
empVQ7naiveHelper = A.Proj [trueAtt deptname] $
  A.Sel (A.Comp EQ (A.Attr managerno) (A.Attr managerno)) $
      A.SetOp A.Prod empVQ3naive (A.TRef dept)

-- classification: 5-3-2-2
empVQ7naive :: A.Algebra
empVQ7naive = A.AChc empv3 empVQ7 $ A.AChc empv4 empVQ7 $ A.AChc empv5 empVQ7 A.Empty

-- note: Just wondering what happens!!!
empVQ7naive' :: A.Algebra
empVQ7naive' = A.AChc empv3 empVQ7naiveHelper $ 
                          A.AChc empv4 empVQ7naiveHelper $ 
                                     A.AChc empv5 empVQ7naiveHelper A.Empty


-- intent: for all managers, find all managers in the department
--         that he/she worked in. (two worked during the same
--         period)
--         (non-temporal join followed by temporal-join)
--         answer using data valid o the year 1991.
-- query:
-- classification:
empVQ8 :: A.Algebra
empVQ8 = undefined

-- 
-- Q9-Q16 is a relaxation of Q1-Q8, in terms of period.
-- 

-- intent: return the salary values of the emp 10004 on 
--         1991-01-01 or after. 
-- query:
-- classification:
empVQ9 :: A.Algebra
empVQ9 = undefined

-- intent: return the managers (of department d001) on
--         1991-01-01 or after.
-- query:
-- classification:
empVQ10 :: A.Algebra
empVQ10 = undefined

-- intent: find all managers that employee 10004 worked with,
--         with overlapping period. answer using data valid 
--         on or after 1991-01-01.
-- query:
-- classification:
empVQ11 :: A.Algebra
empVQ11 = undefined

-- intent: find all salary values of managers in all history.
--         (the periods of salary and manager appointment need
--         to overlap) answer using data valid on or after
--         1991-01-01.
-- query:
-- classification:
empVQ12 :: A.Algebra
empVQ12 = undefined

-- intent: find the historical managers of department where
--         the employee 10004 worked, in all history.
--         (the period of their appointments don't need to 
--         overlap.) answer using data valid on or after
--         1991-01-01.
-- query:
-- classification:
empVQ13 :: A.Algebra
empVQ13 = undefined

-- intent: find all salary values of managers in all history.
--         (the periods of salary and manager appointment don't
--         need to overlap)
--         answer using data valid on or after the year 1991.
-- query:
-- classification:
empVQ14 :: A.Algebra
empVQ14 = undefined

-- intent: for all managers that the employee 10004 worked with, 
--         find all the departments that the manager managed.
--         (temporal join followed by non-temporal join)
--         (10004's and the manager's affiliation with a single
--         department should overlap, but the manager's manager 
--         position periods do not need to overlap, naturally.)
--         anwer using data valid on or after the year 1991.
-- query:
-- classification:
empVQ15 :: A.Algebra
empVQ15 = undefined

-- intent: for all managers, find all managers in the department 
--         that he/she worked in. (two worked during the same 
--         period) (non-temporal join followed by temporal-join)
--         answer using data valid on or after the year 1991.
-- query:
-- classification:
empVQ16 :: A.Algebra
empVQ16 = undefined

-------------------------------------------
-- analysis queries
-------------------------------------------

-- intent: for all employees get their salary
-- query: 
empVQ17 :: A.Algebra
empVQ17 = undefined


-- intent:
-- query:
-- empVQ4 :: A.Algebra
-- empVQ4 = undefined


-- intent:
-- query:
-- empVQ4 :: A.Algebra
-- empVQ4 = undefined


-- intent:
-- query:


-- intent:
-- query:
