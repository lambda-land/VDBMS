-- | vqs for employee database.
module VDBMS.UseCases.EmployeeUseCase.EmployeeQs where

import VDBMS.QueryLang.RelAlg.Variational.Algebra
import VDBMS.UseCases.EmployeeUseCase.EmployeeSchema
import qualified VDBMS.Features.FeatureExpr.FeatureExpr as F
import qualified VDBMS.QueryLang.RelAlg.Variational.Condition as C
import VDBMS.VDB.Name
import VDBMS.DBMS.Value.CompOp
import Prelude hiding (Ordering(..))
import Database.HDBC 

-- import Data.Time.LocalTime
import Data.Time.Calendar

-- keep in mind that the employee use demos deploying
-- every single version for the client of spl. so qs
-- must be st the software generated by spl is actually
-- using it. i.e. qs aren't being run in the test, instead
-- they're running in deployment step. or better yet 
-- you can imagine that different divisions of the company
-- are using different versions of it. so qs demo situations
-- that the user/software has some information need that 
-- needs to get data from different versions. keep in mind
-- that the user/software can definitely specify the version
-- they're requiring at the end, which just requires applying
-- configuration to the final result of a vq or getting the
-- plain q of a vq and then running it on the appropriate 
-- variant. 

newtype QueryT = QueryT String
  deriving (Show, Eq)

-- | attaches the feature expression true to an attribute. 
trueAttr :: Attr -> OptAttribute
trueAttr a = (F.Lit True, genRenameAttr a)

genRenameAlgebra :: Algebra -> Rename Algebra
genRenameAlgebra alg = Rename Nothing alg

genRenameRelation :: Relation -> Rename Relation
genRenameRelation rel = Rename Nothing rel

tRef :: Relation -> Algebra 
tRef rel = TRef $ Rename Nothing rel 

joinTwoRelation :: Relation -> Relation -> Attr -> Algebra
joinTwoRelation rel1 rel2 commonAttr = Join (genRenameAlgebra (tRef rel1)) (genRenameAlgebra (tRef rel2)) join_cond
  where join_cond = C.Comp EQ (C.Att (qualifiedAttr rel1 commonAttr)) (C.Att (qualifiedAttr rel2 commonAttr))

-- | Join three relation(a,b,c) based on commonAttr. 
--   (rel1 join(rel1.commonAttr = rel2.commonAttr) rel2) join(rel1.commonAttr = rel3.commonAttr) rel3
joinThreeRelation :: Relation -> Relation -> Relation -> Attr -> Algebra
joinThreeRelation rel1 rel2 rel3 commonAttr = Join (genRenameAlgebra (joinTwoRelation rel1 rel2 commonAttr)) (genRenameAlgebra (tRef rel3)) cond 
  where cond = C.Comp EQ (C.Att (qualifiedAttr rel1 commonAttr)) (C.Att (qualifiedAttr rel3 commonAttr))

-- 1. 
-- first set of quesries:
-- taken from the prima paper, adjusted to the employee database. 
-- e.g. instead of year 2003, we have year 1991, etc. 
-- can be used for comparison in terms of expressiveness and brevity.
-- 

-- intent: return the salary value of the emp 10004
--         on the year 1991. 
-- query: 
-- prj_salary 
--    (sel_(empNo=10004, 1991-01-01<hiredate<1992-01-01)
--            prj_(empno, hiredate, salary) 
--                empacct join_(title=title) job)
-- note:
-- the year 1991 is included in variants v3, v4, and v5. we only
-- write the query for these variants for a fair comparison against
-- prima.
-- classification: 3-0-2-1

empQ1T :: QueryT
empQ1T = QueryT $ 
  "SELECT salary" ++
  "FROM (SELECT empno, hiredate, salary" ++
        "FROM empacct INNER JOIN job)" ++
  "WHERE empNo = 10004 AND 1991-01-01 < hiredate AND hiredate < 1992-01-01"

empQ1 :: Algebra
empQ1 = Proj [trueAttr salary] $ genRenameAlgebra $
  Sel (VsqlCond (C.And empCond yearCond)) $ 
     genRenameAlgebra $ Proj [trueAttr empno, trueAttr hiredate, trueAttr salary] selection
     where selection = genRenameAlgebra $ Sel (VsqlCond cond) joinedtable 
           joinedtable = genRenameAlgebra (Join (genRenameAlgebra (tRef empacct)) (genRenameAlgebra (tRef job)) cond)
           cond = (C.Comp EQ (C.Att (qualifiedAttr empacct title)) (C.Att (qualifiedAttr job title)))

-- | the year 1991 condition
--   ModifiedJulianDay Int (Count days from 1858-11-17)
--   1991-01-01: ModifiedJulianDay 48257
--   1992-01-01: ModifiedJulianDay 48622

date19910101, date19920101 :: Day
date19910101 = ModifiedJulianDay 48257
date19920101 = ModifiedJulianDay 48622

-- | 1991-01-01 < hiredate < 1992-01-0
yearCond :: C.Condition 
yearCond = C.And (C.Comp GT (C.Val $ SqlLocalDate date19910101) (C.Att  hiredate))
                 (C.Comp LT (C.Att hiredate) (C.Val $ SqlLocalDate date19920101))

-- | employee id = 10004 condition
empCond :: C.Condition
empCond = C.Comp EQ (C.Att empno) (C.Val $ SqlInt32 10004)

-- the variatonal query of empQ1:
-- * v-query considering 5 versions
--   v1 < q1_v1, (v2 or v3 or v4) < q1_v2v3v4, v5 < q1_v4, empty>>>
-- * plain queries for each versiton 
--   q1_v1:  prj_salary 
--          (sel_(empNo=10004, 1991-01-01<hiredate<1992-01-01))
--          (job join_(title=title) engineerpersonnel) join_(tiltle=tiltle) otherpersonnel)
--   q1_v2v3v4:
--     prj_salary 
--     (sel_(empNo=10004, 1991-01-01<hiredate<1992-01-01>))
--     (empacct join_(title=title) job)
--   q1_v5:
--      prj_salary
--     (sel_(empNo=10004, 1991-01-01<hiredate<1992-01-01))
--     empacct 
-- classification: 3-1-2-1

empVQ1 :: Algebra
empVQ1 = AChc empv1 empQ1_v1 $ AChc (F.Or empv2 (F.Or empv3 empv4)) empQ1_v2v3v4 $ AChc empv5 empQ1_v5 Empty
            where empQ1_v1 = Proj [trueAttr salary] $ genRenameAlgebra $ 
                              joinThreeRelation job engineerpersonnel otherpersonnel title 
                  empQ1_v2v3v4 = Proj [trueAttr salary] $ genRenameAlgebra $
                                  Sel (VsqlCond (C.And empCond yearCond)) $ 
                                   genRenameAlgebra $ joinTwoRelation empacct job title
                  empQ1_v5 = Proj [trueAttr salary] $ genRenameAlgebra $ 
                              Sel (VsqlCond (C.And empCond yearCond)) $ genRenameAlgebra $ 
                                tRef empacct 
                            
-- 2. 
-- intent: return the managers (of department d001) on
--         the year 1991.
-- query:
-- prj_managerno (sel_(1991-01-01<hiredate<1992-01-01 and deptno = d001)
--                 empacct join_(managerno=empno) dept)
-- Note:
-- 1. Attribute deptno only exist in v3,v4,v5.
-- v3 or v4 or v5 <q2, empty> OR v3 <q2, v4 < q2, v5 <q2, Empty>>>???

-- classification: 3-0-2-1
departno_value :: SqlValue
departno_value = SqlString "d001"

empQ2T :: QueryT
empQ2T = QueryT $
  "SELECT managerno" ++
  "FROM empacct INNER JOIN dept ON managerno = empNo" ++
  "WHERE deptno = d001 AND 1991-01-01 < hiredate AND hiredate < 1992-01-01"

empQ2 :: Algebra
empQ2 = Proj [trueAttr managerno] $ genRenameAlgebra $ 
                  Sel (VsqlCond cond) $ genRenameAlgebra $ 
                  joinTwoRelation empacct dept deptno
      where cond = (C.Comp EQ (C.Att deptno) (C.Val departno_value)) `C.And ` yearCond

-- | VQ2 or VQ2naive, which one should use??
empVQ2 :: Algebra
empVQ2 = AChc (empv3 `F.Or` empv4 `F.Or` empv5) empQ2 Empty

empVQ2naive :: Algebra
empVQ2naive = AChc empv3 empVQ2 (AChc empv4 empVQ2 $ AChc empv5 empVQ2 Empty)

-- 3. 
-- intent: find all managers that the employee 10004 worked with,
--         on the year 1991. 
-- query:
-- prj_managerno (dept join_(deptno=deptno) 
--                prj_deptno (sel_(empNo=10004, 1991-01-01<hiredate<1992-01-01) empacct))
-- note:
-- the naive and manually optimized queries are basically the same.
-- classification: 3-0-2-1
empQ3T :: QueryT
empQ3T = QueryT $
  "SELECT managerno" ++
  "FROM empacct join dept on deptno" ++  
  "WHERE empno = 10004 AND 1991-01-01 < hiredate AND hiredate < 1992-01-01) as t1"

empno_value :: SqlValue 
empno_value  = SqlInt32 10004

empQ3 :: Algebra
empQ3 = Proj [trueAttr managerno] $ genRenameAlgebra $ 
  Sel (VsqlCond ((yearCond `C.And` (C.Comp EQ (C.Att empno) (C.Val empno_value)) ))) $ genRenameAlgebra $ 
  joinTwoRelation empacct dept deptno 

-- | v3 or v4 or v5 <q2, empty>
empVQ3 :: Algebra
empVQ3 = AChc (empv3 `F.Or` empv4 `F.Or` empv5) empQ2 Empty

-- classification: 5-3-2-1
empVQ3naive :: Algebra
empVQ3naive = AChc empv3 empQ3 (AChc empv4 empQ3 $ AChc empv5 empQ3 Empty)


-- intent: find all salary values of managers in all history,
--         during the period of manager appointment. (the periods
--         of salary and manager appointment need to overlap).
--         answer using data valid on the year 1991.
-- * variational query:
--   v3 o v4<empQ4_v3v4, v5<empQ4_v5, empty>>
-- 
-- * palin query for each version:
--   * for v3, v4:
--    prj_(managerno, salary) 
--     sel_(1991-01-01<hiredate<1992-01-01) 
--       (empacct join_(title = title) job join_(managerno = empno) dept) 
--   * for v5:
--    prj_(managerno, salary) 
--     sel_(1991-01-01<hiredate<1992-01-01) 
--       (empacct join_(managerno = empno) dept)      
-- note: 
-- check to see if the join only occurs for valid variants!!
-- i.e. ... join dept is only valid for v3, v4, and v5. 
-- and ... join job is not valid for v5.
-- classification: 3-0-3-2

empQ4_v3v4 :: Algebra
empQ4_v3v4 = Proj [trueAttr managerno, trueAttr salary] $ genRenameAlgebra $ 
          Sel (VsqlCond yearCond) $ genRenameAlgebra $ 
          Join (genRenameAlgebra join_empacct_job) (genRenameAlgebra (tRef dept)) cond 
    where join_empacct_job = joinTwoRelation empacct job title 
          cond = C.Comp EQ (C.Att empno) (C.Att managerno)

empQ4_v5 :: Algebra
empQ4_v5 = Proj [trueAttr managerno, trueAttr salary] $ genRenameAlgebra $ 
          Sel (VsqlCond yearCond) $ genRenameAlgebra $ 
          Join (genRenameAlgebra (tRef empacct)) (genRenameAlgebra (tRef dept)) cond 
    where cond = C.Comp EQ (C.Att empno) (C.Att managerno)

empVQ4naive :: Algebra
empVQ4naive = AChc (F.Or empv3 empv4)
                empQ4_v3v4
                (AChc empv5 empQ4_v5 Empty)
{-
-- intent: find the historical managers of department where the
--         employee 10004 worked, in all history. (the period 
--         of their appointments don't need to overlap.)
--         answer using data valid on the year 1991.
-- query:
-- prj_managerno
--     sel_(1991-01-01<hiredate<1992-01-01)
--         ((sel_(empno == 10004) empacct) join_(deptno = deptno) dept)
-- classification: 3-0-2-1
empVQ5 :: Algebra
empVQ5 = Proj [trueAtt managerno] $
  Sel (C.And yearCond 
             (C.Comp EQ (C.Attr deptno) (C.Attr deptno))) $
      SetOp Prod (Sel empCond (TRef empacct))
                 (TRef dept)

-- a less efficient vq in terms of relational algebra and sql.
-- since we're joining first and then applying the selection of
-- the particular employee. i.e.:
-- query:
-- prj_managerno
--     sel_(1991-01-01<hiredate<1992-01-01 and empno == 10004)
--         (empacct join_(deptno = deptno) dept)
-- classification: 3-0-2-1
empVQ5' :: Algebra
empVQ5' = Proj [trueAtt managerno] $
  Sel (C.And yearCond $
       C.And empCond 
             (C.Comp EQ (C.Attr deptno) (C.Attr deptno))) $
      SetOp Prod (TRef empacct)
                 (TRef dept)

-- classification: 5-3-2-1
empVQ5naive :: Algebra
empVQ5naive = AChc empv3 empVQ5 $ AChc empv4 empVQ5 $ AChc empv5 empVQ5 Empty

-- classification: 5-1-2-1
empVQ5naive' :: Algebra
empVQ5naive' = AChc (F.disjFexp [empv3, empv4, empv5]) empVQ5 Empty

-- intent: find all salary values of managers in all history.
--         (the periods of salary and manager appointment 
--         don't need to overlap.) 
--         answer using data valid on the year 1991.
-- query:
-- classification:
-- note: there's no way to get the period of manager appointment.
empVQ6 :: Algebra
empVQ6 = empVQ4

-- intent: for all managers that the employee 10004 worked with,
--         find all the departments that the manager managed.
--         (temporal join followed by non-temporal join)
--         (10004's and the manager's affiliation with a single 
--         department should overlap, but the manager's manager
--         position periods do not need to overlap, naturally.)
--         answer using data valid on the year 1991.
-- query:
-- prj_deptname
--     empvq3 join_(managerno = managerno) dept
-- classification: 3-0-2-2
empVQ7 :: Algebra
empVQ7 = Proj [trueAtt deptname] $
  Sel (C.Comp EQ (C.Attr managerno) (C.Attr managerno)) $
      SetOp Prod empVQ3 (TRef dept)

-- just wondering about!!
empVQ7naiveHelper :: Algebra
empVQ7naiveHelper = Proj [trueAtt deptname] $
  Sel (C.Comp EQ (C.Attr managerno) (C.Attr managerno)) $
      SetOp Prod empVQ3naive (TRef dept)

-- classification: 5-3-2-2
empVQ7naive :: Algebra
empVQ7naive = AChc empv3 empVQ7 $ AChc empv4 empVQ7 $ AChc empv5 empVQ7 Empty

-- note: Just wondering what happens!!!
empVQ7naive' :: Algebra
empVQ7naive' = AChc empv3 empVQ7naiveHelper $ 
                          AChc empv4 empVQ7naiveHelper $ 
                                     AChc empv5 empVQ7naiveHelper Empty


-- intent: for all managers, find all managers in the department
--         that he/she worked in. (two worked during the same
--         period)
--         (non-temporal join followed by temporal-join)
--         answer using data valid o the year 1991.
-- query:
-- classification:
empVQ8 :: Algebra
empVQ8 = undefined

-- 
-- Q9-Q16 is a relaxation of Q1-Q8, in terms of period.
-- 

-- intent: return the salary values of the emp 10004 on 
--         1991-01-01 or after. 
-- query:
-- classification:
empVQ9 :: Algebra
empVQ9 = undefined

-- intent: return the managers (of department d001) on
--         1991-01-01 or after.
-- query:
-- classification:
empVQ10 :: Algebra
empVQ10 = undefined

-- intent: find all managers that employee 10004 worked with,
--         with overlapping period. answer using data valid 
--         on or after 1991-01-01.
-- query:
-- classification:
empVQ11 :: Algebra
empVQ11 = undefined

-- intent: find all salary values of managers in all history.
--         (the periods of salary and manager appointment need
--         to overlap) answer using data valid on or after
--         1991-01-01.
-- query:
-- classification:
empVQ12 :: Algebra
empVQ12 = undefined

-- intent: find the historical managers of department where
--         the employee 10004 worked, in all history.
--         (the period of their appointments don't need to 
--         overlap.) answer using data valid on or after
--         1991-01-01.
-- query:
-- classification:
empVQ13 :: Algebra
empVQ13 = undefined

-- intent: find all salary values of managers in all history.
--         (the periods of salary and manager appointment don't
--         need to overlap)
--         answer using data valid on or after the year 1991.
-- query:
-- classification:
empVQ14 :: Algebra
empVQ14 = undefined

-- intent: for all managers that the employee 10004 worked with, 
--         find all the departments that the manager managed.
--         (temporal join followed by non-temporal join)
--         (10004's and the manager's affiliation with a single
--         department should overlap, but the manager's manager 
--         position periods do not need to overlap, naturally.)
--         anwer using data valid on or after the year 1991.
-- query:
-- classification:
empVQ15 :: Algebra
empVQ15 = undefined

-- intent: for all managers, find all managers in the department 
--         that he/she worked in. (two worked during the same 
--         period) (non-temporal join followed by temporal-join)
--         answer using data valid on or after the year 1991.
-- query:
-- classification:
empVQ16 :: Algebra
empVQ16 = undefined

-------------------------------------------
-- analysis queries
-------------------------------------------

-- intent: for all employees get their salary
-- query: 
empVQ17 :: Algebra
empVQ17 = undefined


-- intent:
-- query:
-- empVQ4 :: Algebra
-- empVQ4 = undefined


-- intent:
-- query:
-- empVQ4 :: Algebra
-- empVQ4 = undefined


-- intent:
-- query:


-- intent:
-- query:
-}
